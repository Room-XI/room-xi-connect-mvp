-- Enable extensions
create extension if not exists pgcrypto;
create extension if not exists "uuid-ossp";
create extension if not exists btree_gin;

-- Tables
create table if not exists public.programs (
  id uuid primary key default gen_random_uuid(),
  title text not null,
  description text,
  tags text[] not null default '{}',
  free boolean not null default true,
  indoor boolean,
  outdoor boolean,
  cost_cents integer,
  location_name text,
  address text,
  lat text,
  lng text,
  organizer text,
  accessibility_notes text,
  next_start timestamptz,
  next_end timestamptz,
  created_at timestamptz not null default now()
);

create table if not exists public.saved_programs (
  user_id uuid not null references auth.users(id) on delete cascade,
  program_id uuid not null references public.programs(id) on delete cascade,
  created_at timestamptz not null default now(),
  primary key (user_id, program_id)
);

create table if not exists public.checkins (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  "timestamp" timestamptz not null,
  dimension text not null,
  mood_level_1_6 int not null check (mood_level_1_6 between 1 and 6),
  affect_tags text[] not null default '{}',
  note text check (note is null or length(note) <= 140),
  local_tz text,
  created_at timestamptz not null default now()
);
create unique index if not exists checkins_one_per_day_idx on public.checkins (user_id, (("timestamp" at time zone 'America/Edmonton')::date));
create index if not exists checkins_user_ts_idx on public.checkins (user_id, "timestamp" desc);

create table if not exists public.profiles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  weights jsonb,
  scores jsonb,
  streak_count int default 0,
  last_checkin_date date,
  is_admin boolean not null default false
);

create table if not exists public.xids (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  xid_hash text not null unique,
  checksum text,
  tombstoned_at timestamptz,
  created_at timestamptz not null default now()
);

create table if not exists public.attendance (
  id uuid primary key default gen_random_uuid(),
  xid_id uuid not null references public.xids(id) on delete cascade,
  program_id uuid not null references public.programs(id) on delete cascade,
  "timestamp" timestamptz not null,
  method text not null check (method in ('qr','manual')),
  site text,
  created_at timestamptz not null default now()
);
create index if not exists attendance_xid_ts_idx on public.attendance (xid_id, "timestamp" desc);

create table if not exists public.consents (
  user_id uuid not null references auth.users(id) on delete cascade,
  key text not null,
  value boolean not null,
  ip_address text,
  user_agent text,
  updated_at timestamptz not null default now(),
  primary key (user_id, key)
);

create table if not exists public.crisis_supports (
  id uuid primary key default gen_random_uuid(),
  region text not null,
  category text not null check (category in ('call','textchat','inperson')),
  name text not null,
  phone text,
  text_code text,
  chat_url text,
  address text,
  hours text,
  notes text,
  verified_at timestamptz,
  created_at timestamptz not null default now()
);

-- Admin Audit Log Table (Fix for R-04: Admin Account Takeover)
create table if not exists public.admin_logs (
    id bigint generated by default as identity primary key,
    user_id uuid references auth.users(id),
    action text not null,
    table_name text not null,
    record_id uuid,
    old_record jsonb,
    new_record jsonb,
    timestamp timestamptz default now()
);

-- Trigger function for admin logs
create or replace function public.log_program_changes()
returns trigger as $$
declare
  record_id uuid;
  user_id uuid;
begin
  user_id := auth.uid();
  if (TG_OP = 'INSERT') then
    record_id := NEW.id;
    insert into public.admin_logs (user_id, action, table_name, record_id, new_record)
    values (user_id, TG_OP, TG_TABLE_NAME, record_id, row_to_json(NEW));
    return NEW;
  elsif (TG_OP = 'UPDATE') then
    record_id := NEW.id;
    insert into public.admin_logs (user_id, action, table_name, record_id, old_record, new_record)
    values (user_id, TG_OP, TG_TABLE_NAME, record_id, row_to_json(OLD), row_to_json(NEW));
    return NEW;
  elsif (TG_OP = 'DELETE') then
    record_id := OLD.id;
    insert into public.admin_logs (user_id, action, table_name, record_id, old_record)
    values (user_id, TG_OP, TG_TABLE_NAME, record_id, row_to_json(OLD));
    return OLD;
  end if;
  return null;
end;
$$ language plpgsql security definer;

-- Attach trigger to programs table
create trigger programs_audit_trigger
after insert or update or delete on public.programs
for each row execute function public.log_program_changes();

-- RPC function for secure check-ins (Fix for R-02: Check-in Data Sensitivity)
create or replace function public.create_or_update_checkin(
  p_timestamp timestamptz,
  p_dimension text,
  p_mood_level_1_6 int,
  p_affect_tags text[],
  p_note text default null,
  p_local_tz text default null
)
returns uuid
language plpgsql
security definer
as $$
declare
  v_user_id uuid;
  v_checkin_id uuid;
  v_date date;
  v_existing_id uuid;
begin
  -- Get authenticated user
  v_user_id := auth.uid();
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  -- Validate inputs
  if p_mood_level_1_6 < 1 or p_mood_level_1_6 > 6 then
    raise exception 'Invalid mood level: must be between 1 and 6';
  end if;
  
  if p_dimension not in ('mood', 'energy', 'anxiety', 'focus') then
    raise exception 'Invalid dimension: must be mood, energy, anxiety, or focus';
  end if;

  if p_note is not null and length(p_note) > 140 then
    raise exception 'Note too long: maximum 140 characters';
  end if;

  -- Calculate date in Edmonton timezone for uniqueness check
  v_date := (p_timestamp at time zone 'America/Edmonton')::date;

  -- Check for existing check-in on this date
  select id into v_existing_id
  from public.checkins
  where user_id = v_user_id
    and (("timestamp" at time zone 'America/Edmonton')::date) = v_date;

  if v_existing_id is not null then
    -- Update existing check-in
    update public.checkins
    set
      "timestamp" = p_timestamp,
      dimension = p_dimension,
      mood_level_1_6 = p_mood_level_1_6,
      affect_tags = p_affect_tags,
      note = p_note,
      local_tz = p_local_tz
    where id = v_existing_id;
    
    v_checkin_id := v_existing_id;
  else
    -- Create new check-in
    insert into public.checkins (
      user_id,
      "timestamp",
      dimension,
      mood_level_1_6,
      affect_tags,
      note,
      local_tz
    ) values (
      v_user_id,
      p_timestamp,
      p_dimension,
      p_mood_level_1_6,
      p_affect_tags,
      p_note,
      p_local_tz
    ) returning id into v_checkin_id;
  end if;

  -- Update profile streak
  insert into public.profiles (user_id, last_checkin_date, streak_count)
  values (v_user_id, v_date, 1)
  on conflict (user_id) do update set
    last_checkin_date = v_date,
    streak_count = case
      when profiles.last_checkin_date = v_date - interval '1 day' then profiles.streak_count + 1
      when profiles.last_checkin_date = v_date then profiles.streak_count
      else 1
    end;

  return v_checkin_id;
end;
$$;
